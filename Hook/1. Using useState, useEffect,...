1. Useful
- Allow for attaching reuse logic to component
- Use state and lifecycle inside React functional component
- Build 100% app with React functional component (without class)

2. Two way binding
- Ý tưởng: mỗi khi user nhìn thấy gì đó mới trên màn hình thì tức là nó đang được theo dõi với trạng thái mới (new state)
- VD: Khi user dùng trình duyệt nhập vào input. Mỗi ký tự mà user nhập sẽ kích hoạt 1 sự kiện, và sự kiện đó sẽ thay thế giá trị hiện tại bằng giá trị mới

3. useState
const [count, setCount] = useState(0);
- Giá trị của count ban đầu là 0
- useState sẽ trả về một mảng

onChange={(e) => {setCount(e.target.value)}}

4. useRef: cho phép access trực tiếp vào DOM
const imageRef = useRef(null)
<img onMouseOver={() => { imageRef.current.src = 'http:://' }} src={imageUrl} ref={imageRef}/>
- Bây giờ chúng ta có thể truy cập imag.current

5. useEffect:
- sử dụng thay thế cho lifecycle hooks
- useEffect nhận param là 1 function
- run for every update
- Kết hợp cả 3 hooks: didMount, didUpdate và willUnmout
- Có thể tạo nhiều useEffect để quản lý side-effect
+ Tham số đầu tiên của useEffect là 1 hàm thực thi
+ Tham số thứ hai là mảng dependency

useEffect(() => {
  //Http request
})

*** didMount
useEffect(() => {
  axios.get(listPerson);
}, []) //no dependencies -> never run (chỉ run first time)

*** didUpdate
useEffect(() => {
  axios.post(savePerson);
}, [props.person]) //chỉ định khi person change thì useEffect này mới thực thi
-> useEffect này đang bao gồm didMount và didUpdate

*** willUnmout
useEffect(() => {
  axios.get(listPerson);
  
  return () => {
    //cleanup work
  }
}, [])

- Dưới đây là trường hợp có thể hữu dụng khi muốn cancel 1 số hoạt động mỗi khi re-render
useEffect(() => { //nếu không có argument thì sẽ luôn chạy khi re-render
  console.log('Chạy thứ 2')
  return () => {
    console.log('Chạy trước')
    //cleanup work 
  }
})

